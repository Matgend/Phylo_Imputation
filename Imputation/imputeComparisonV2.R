#Impute the missing data using the function described in "imputationApproaches.R"
################################################################################

#import imputation functions
source("./Imputation/imputationApproaches.R")


#ERROR
######
#' @title Calculate error of imputation
#'
#' @description This function calculates the RMSE for imputed continuous data, the absolute 
#' error for imputed ordinal data and misclassification for the other subcategories of discrete data
#'
#' @usage imputationError(imputedData, trueData, missingData, imputationApproachesName, Data)
#'
#' @param imputedData array of imputed data
#' @param trueData array of true data
#' @param missingData array of data with missing values
#' @param Data simulated Data object
#' @return return a data.frame with in the first column the trait names and in the second the errors
#'
imputationError <- function(imputedData, trueData, missingData, imputationApproachesName, Data){
  
  #get the ordinal trait reference
  ordinalTraits <- which(Data$dataframe$class == "ordinal")
  
  errors <- c()
  traitNames <- c() 
  for (c in 1:ncol(missingData)){
    
    #know is NaNs in the columns(trait)
    NaNRowIndex <- which(is.na(missingData[,c]))
    
    if(length(NaNRowIndex != 0)){
      
      traitNames <- c(traitNames, names(trueData[c]))
      missingValues <- missingData[NaNRowIndex, c]
      trueValues <- trueData[NaNRowIndex, c]
      imputedValues <- imputedData[NaNRowIndex, c]
      
      #in case continuous data
      if(length(grep("F.", names(missingData)[c])) == 1){
        
        #rmse
        error <- sqrt(mean((as.numeric(imputedValues) - as.numeric(trueValues))^2))
        
      }
      
      #in case ordinal trait
      else if(length(grep(paste0("/", ordinalTraits), names(missingData)[c])) == 1){
        
        #imputation error for ordinal traits (absolute error)
        error <- mean(abs((as.numeric(imputedValues) - as.numeric(trueValues)) / as.numeric(trueValues)))
      }
      
      #in case discrete data
      else{
        error <- length(setdiff(imputedValues, trueValues)) / length(trueValues)
      }
      errors <- c(errors, error)
    }
  }
  output <- data.frame(trait = traitNames, c2 = errors)
  names(output)[2] <- imputationApproachesName

  return(output)
}

#' @title Delete empty list
#'
#' @description This function delete lists of list that are empty 
#'
#' @usage deleteEmptylist(lists)
#'
#' @param lists list containing lists (lists of list)
#' @return return the list of lists without the empty list

deleteEmptylist <- function(lists){
  saveIndex <- c()
  for (l in 1:length(lists)){
    if(length(lists[[l]]) == 0){
      saveIndex <- c(saveIndex, l)
    }
  }
  if (length(saveIndex) != 0){
    lists[[saveIndex]] <- NULL
  }
  return(lists)
}



#' @title Impute matrix containing missing values
#'
#' @description This function imputes the dataset containing missing values with Rphylopars, corHMM, 
#' MICE, missForest and KNN according the percentage of phylogenetic information.
#' 
#' @usage generateResults(ImputationApproachesNames, NaNImputed, Data, variance_fractions, save = NULL)
#'
#' @param ImputationApproachesNames names of the imputations methods (character vector)
#' @param NaNImputed object containing all the dataset with missing values
#' @param Data simulated Data object
#' @param variance_fractions numerical vector containing the amount of phylogenetic information to include for 
#' the imputation
#' @param save name of the output
#' @return return a .RData object with the data imputed and all the parameters used for.
#'
generateResults <- function(ImputationApproachesNames, NaNImputed, Data, variance_fractions, save = NULL){
  #save all data generated by replicates
  FinalOutput <- list()
  
  #save error by replicates (MCAR, MAR, MNAR, PhyloNA)
  OutputErrorsDataframes <- list()

  #save imputed data
  OutputImputedData <- list()
  OutputImputedDataNames <- c()

  replicate <- NaNImputed$DataNaN

  replicate <- deleteEmptylist(replicate)
  
  #variables to define for imputation
  nbrMI <- 5
  k <- 2
  numFun <- weightedMedian
  catFun <- maxCat

  
  #Define columns for TimeDataframe
  randomType <- c()
  missingDegree <- c()
  partitionName <- c()
  imputeApproachName <- c() #next loop
  var_fraction <- c() #next lopp
  time <- c() #next loop
  
  for(rdn in 1:length(replicate)){
    
    errorDataframes <- list()
    errorDataframeNames <- c()
    imputedData <- list()
    imputedDataNames <- c()

    randomApproaches <- replicate[[rdn]]

    subdatasNames <- str_split(names(randomApproaches), "/", simplify = TRUE)
    
    #define error dataframe, contain error value for each trait containing missing values
    uniqueErrorName <- "error"
    errorSubdata <- NULL
    for (p in (1:length(randomApproaches))){
      partition <- randomApproaches[[p]]

      randomType <- c(randomType, rep(subdatasNames[,1][p], each = ((length(ImputationApproachesNames) - 2) 
                                                                    * length(variance_fractions) + 2))) 
      
      missingDegree <- c(missingDegree, rep(subdatasNames[, ncol(subdatasNames)][p],
                                            each = ((length(ImputationApproachesNames) - 2) 
                                                    * length(variance_fractions) + 2)))
      
      #define column partitionName
      rows <- paste(sort(unique(as.character(str_extract(colnames(partition), "(?<=\\/)\\d+")))), collapse = "/")
      pName <- rep(paste(subdatasNames[,2][p], rows, sep = "/"),
                   each = ((length(ImputationApproachesNames) - 2) 
                           * length(variance_fractions) + 2))
      
      errorName <- paste(unique(randomType)[rdn], unique(pName), sep = "/")
      
      #load true data
      trueData <- Data$FinalData[, names(partition), drop = FALSE]
      
      if(rdn == length(replicate)){
        
        #full Data 
        fullData <- Data$FinalData
        
        #replace the missing data in the fullData
        fullData[row.names(partition), colnames(partition)] <- partition
        partition <- fullData
        
        pName <- rep(subdatasNames[,2][p], each = ((length(ImputationApproachesNames) - 2) 
                                                   * length(variance_fractions) + 2))
        missD <- rep(unique(missingDegree), (length(randomApproaches) / length(unique(missingDegree))))
        errorName <- paste(unique(randomType)[rdn], unique(pName), missD[p], sep = "/")
        
        trueData <- Data$FinalData[row.names(partition), colnames(partition), drop = FALSE]
        
      }
      partitionName <- c(partitionName, pName)
      if(!is.null(errorSubdata) & errorName != uniqueErrorName){
        errorDataframes <- c(errorDataframes, list(errorSubdata))
      }

      if(errorName != uniqueErrorName){
        
        if(rdn == length(replicate)){
          errorDataframeNames <- c(errorDataframeNames, errorName)
        }
        
        uniqueErrorName <- errorName
        approachesName <- rep(ImputationApproachesNames[-c(1,2)], length(variance_fractions))
        var_frac <- rep(variance_fractions, each = length(ImputationApproachesNames[-c(1,2)]))
        
        if(rdn != length(replicate)){
          errorDataframeNames <- c(errorDataframeNames, uniqueErrorName)
        }
        errorSubdata <- NULL
      }
      
      #imputed Data names
      approachesName <- rep(ImputationApproachesNames[-c(1,2)], length(variance_fractions))
      var_frac <- rep(variance_fractions, each = length(ImputationApproachesNames[-c(1,2)]))
      
      if(rdn != length(replicate)){
        missD <- rep(unique(missingDegree), (length(randomApproaches) / length(unique(missingDegree))))
        errorName <- paste(unique(randomType)[rdn], unique(pName), missD[p], sep = "/")
      }
        
      if(length(grep("I.", names(partition))) == ncol(partition)){
        impName <- paste(errorName, ImputationApproachesNames[1], "Imputed", sep = "/")
        if(ncol(partition) == 1){
          imputedDataNames <- c(imputedDataNames, impName)
        }
        else{
          imputedDataNames <- c(imputedDataNames, c(impName, paste(errorName, var_frac, 
                                                                   approachesName, "Imputed", sep = "/")))
        }
      }
      
      if(length(grep("F.", names(partition))) == ncol(partition)){
        impName <- paste(errorName, ImputationApproachesNames[2], "Imputed", sep = "/")
        if(ncol(partition) == 1){
          imputedDataNames <- c(imputedDataNames, impName)
        }
        else{
          imputedDataNames <- c(imputedDataNames, c(impName, paste(errorName, var_frac, 
                                                                   approachesName, "Imputed", sep = "/")))
        }
      }
      if(length(grep("F.", names(partition))) != ncol(partition) & 
         length(grep("I.", names(partition))) != ncol(partition)){
        imputedDataNames <- c(imputedDataNames, paste(errorName, approachesName, "Imputed", sep = "/"))
      }

      imputeA <- NA
      varf <- NA
      t <- NA
      error <- NULL
      #only discrete data
      if(length(grep("I.", names(partition))) == ncol(partition)){
        start_time <- Sys.time()
        imputedTrait <- imputeDiscreteTraits(partition, Data)
        end_time <- Sys.time()

        imputeA <- ImputationApproachesNames[1]
        varf <- 1
        if(rdn == length(replicate)){
          error <- imputationError(imputedTrait, trueData, partition, 
                                            paste(imputeA, subdatasNames[p, 3], sep = "/"), Data)
        }
        else{
          error <- imputationError(imputedTrait, trueData, partition, paste(imputeA, subdatasNames[p, 4], sep = "/"), Data)
        }
        t <- end_time - start_time
        imputedData <- c(imputedData, list(imputedTrait))

      }
      
      imputeApproachName <- c(imputeApproachName, imputeA)
      var_fraction <- c(var_fraction, varf)
      time <- c(time, t)

      imputeA <- NA
      varf <- NA
      t <- NA
      #only continuous data
      if(length(grep("F.", names(partition))) == ncol(partition)){
        start_time <- Sys.time()
        imputedTrait <- imputeContinousTraits(partition, Data)
        end_time <- Sys.time()
        
        imputeA <- ImputationApproachesNames[2]
        varf <- 1
        if(rdn == length(replicate)){
          error <- imputationError(imputedTrait, trueData, partition, 
                                   paste(imputeA, subdatasNames[p, 3], 1, sep = "/"), Data)
        }
        else{
          error <- imputationError(imputedTrait, trueData, partition, 
                                   paste(imputeA, subdatasNames[p, 4], 1, sep = "/"), Data)
        }

        t <- end_time - start_time
        imputedData <- c(imputedData, list(imputedTrait))
        
      }
      
      imputeApproachName <- c(imputeApproachName, imputeA)
      var_fraction <- c(var_fraction, varf)
      time <- c(time, t)
      
      if(!is.null(errorSubdata) & !is.null(error)){
        errorSubdata <- merge(errorSubdata, error, by = "trait")
      }
      
      if(is.null(errorSubdata) & !is.null(error)){
        errorSubdata <- error
      }

      #mixed and/or only continuous and/or only discrete data
      for(v in variance_fractions){
        
        method <- 1
        while(method < ((length(ImputationApproachesNames) - 2) * 2)){

          MixedImputationApproaches <- list("imputeMICE", list(partition, nbrMI, method = "pmm",
                                                               v, Data),
                                            "imputeMissForest", list(partition, v,
                                                                     maxiter = 10, ntree = 100,
                                                                     mtry = sqrt(ncol(partition)), Data),
                                            "imputeKNN", list(partition, k, numFun, catFun,
                                                              v, Data))
          

          imputeApproachName <- c(imputeApproachName, MixedImputationApproaches[[method]])
          var_fraction <- c(var_fraction, v)

          #univariate, missrandomForest and imputeKNN don't work.
          if((MixedImputationApproaches[[method]] == "imputeMICE" |
             MixedImputationApproaches[[method]] == "imputeMissForest" |
             MixedImputationApproaches[[method]] == "imputeKNN") & ncol(partition) == 1){
            method <- method + 2
            time <- c(time, NA)
            next
          }

          start_time <- Sys.time()
          imputedTrait <- do.call(MixedImputationApproaches[[method]], MixedImputationApproaches[[method + 1]])
          end_time <- Sys.time()
          imputedData <- c(imputedData, list(imputedTrait))
          
          if(is.null(imputedTrait)){
            time <- c(time, NA)
          }
          
          if(!is.null(imputedTrait)){
            time <- c(time, end_time - start_time)
          }
          
          if(rdn == length(replicate)){
            error <- imputationError(imputedTrait, trueData, partition, 
                                     paste(MixedImputationApproaches[[method]],
                                           subdatasNames[p, 3], v, sep = "/"), Data)
          }
          
          if(rdn != length(replicate)){
            error <- imputationError(imputedTrait, trueData, partition, 
                                     paste(MixedImputationApproaches[[method]], 
                                           subdatasNames[p, 4], v, sep = "/"), Data)
          }
          
          if(!is.null(errorSubdata)){
            errorSubdata <- merge(errorSubdata, error, by = "trait")
          }
          
          if(is.null(errorSubdata)){
          errorSubdata <- error
          }

          method <- method + 2
        }
      }
    }
    
    errorDataframes <- c(errorDataframes, list(errorSubdata))
    OutputErrorsDataframes[[rdn]] <- errorDataframes
    names(OutputErrorsDataframes[[rdn]]) <- errorDataframeNames
    names(OutputErrorsDataframes)[rdn] <- paste("Error", names(replicate)[rdn], sep = "/")
    
    OutputImputedData[[rdn]] <- imputedData
    names(OutputImputedData[[rdn]]) <- imputedDataNames
    names(OutputImputedData)[rdn] <- paste("Imputed", names(replicate)[rdn], sep = "/")
  }
  TimeDataframe <- data.frame(random_Type = randomType, partition = partitionName,
                              missing_Degree = missingDegree, variance_fractions = var_fraction,
                              impute_Approach = imputeApproachName, time = time)

  
  #remove rows with missingData
  TimeDataframe <- TimeDataframe[-which(is.na(TimeDataframe$time)), ]
  
  if(length(replicate) == 3){
    FinalOutput <- list(TimeDataframe = TimeDataframe, 
                        MCAR = list(Error = OutputErrorsDataframes[[1]], Imputed = OutputImputedData[[1]]), 
                        MNAR = list(Error = OutputErrorsDataframes[[2]], Imputed = OutputImputedData[[2]]), 
                        PhyloNA = list(Error = OutputErrorsDataframes[[3]], Imputed = OutputImputedData[[3]]))
  }
  
  else{
    FinalOutput <- list(TimeDataframe = TimeDataframe, 
                        MCAR = list(Error = OutputErrorsDataframes[[1]], Imputed = OutputImputedData[[1]]), 
                        MAR = list(Error = OutputErrorsDataframes[[2]], Imputed = OutputImputedData[[2]]), 
                        MNAR = list(Error = OutputErrorsDataframes[[3]], Imputed = OutputImputedData[[3]]),
                        PhyloNA = list(Error = OutputErrorsDataframes[[4]], Imputed = OutputImputedData[[4]]))
  }
  
  if(!is.null(save)){
    save(FinalOutput, file = paste0(save, ".RData"))
  }
  
  return(FinalOutput)
}


#' @title Calculate the mean of the error for a partition
#'
#' @description This function calculate the mean of error of a partition for. Mean of all each columns of the matrix containing the error value of each traits obtains with each imputation methods. 
#'
#' @usage meanPartition(ErrorOutputObjects)
#'
#' @param ErrorOutputObjects matrix of imputation error. Row: traits, columns: imputation method/
#' variance fraction/missingness
#' @return return list containing the mean of the error for each random approaches and each partition.

meanPartition <- function(ErrorOutputObject){
  MeanOuput <- list()
  
  for(rdn in 2:length(ErrorOutputObject)){
    partitions <- ErrorOutputObject[[rdn]]$Error

    partitionMean <- list()
    for(d in 1:length(partitions)){
      meanCols <- colMeans(partitions[[d]][, -1])
      name <- str_split(names(meanCols), "/", simplify = TRUE)
      rowNames <- unique(name[,1])
      colNames <- unique(paste(name[,2], name[,3], sep = "/"))
      meansVector <- 1:(length(rowNames)*length(colNames))
  
      if(rowNames[1] == "imputeDiscrete" | rowNames[1] == "imputeContinuous"){
        missingValtoKeep <- name[which(name[,1] == rowNames[1]),2]
        indexNA <- seq(1, length(meansVector), by = length(rowNames))
        NAcols <- seq(1, length(meansVector), by = length(rowNames)^2)
        for(i in NAcols){
          indexNA <- indexNA[-which(indexNA == i)]
          indexNA <- c(indexNA, (i+1):(i+length(rowNames) - 1))
        }
        sort(indexNA)
        meansVector[indexNA] <- NA
        meansVector[which(!is.na(meansVector))] <- meanCols
        
        #create a matrix to fill
        meanCols <- matrix(data = meansVector, nrow = length(rowNames), ncol = length(colNames))
      }
      
      else{
        meanCols <- t(meanCols)
        dim(meanCols) <- c(length(rowNames), dim(meanCols)[2]/length(rowNames))
      }
      
      rownames(meanCols) <- rowNames
      colnames(meanCols) <- colNames
      partitionMean[[d]] <- meanCols
      names(partitionMean)[d] <- names(partitions[d])
    }
    MeanOuput[[rdn - 1]] <- partitionMean
  }
  names(MeanOuput) <- names(ErrorOutputObject)[-1]
 
  return(MeanOuput) 
}

#' @title download files
#'
#' @description This function downloads the replicate files of same simulation. 
#'
#' @usage loadReplicates(integer, filesInFolder, pathDataframe)
#'
#' @param simDataFolder: character vector with name of simulation data
#' @param filesInFolder: character vector with name of the replicate files
#' @param phatDataframe: path where the .csv file are
#' @return return a character vector with all the replicates of the same type of simulated data

loadReplicates <- function(integer, filesInFolder, pathDataframe){
  simDataFolder <- list.files(path = pathDataframe, pattern = "*.csv")
  simDataname <- unique(gsub("\\.csv", "", simDataFolder))
  pattern <- simDataname[integer]
  replicatesFiles <- grep(pattern, filesInFolder, value = T)

  return(replicatesFiles)
}

#' @title Mean of all the replicates
#'
#' @description This function calculates the overall mean of all the replicates for the same type of simulated data
#'
#' @usage overallMean(namesReplicates, path, pathReplicates)
#'
#' @param namesReplicates: character string with replicate name files
#' @param path: path where want to save the data
#' @param pathReplicates: path of the directory containing the replicates
#' @return return a .RData object with a matrix for each random approaches and partition with the overall mean error
#' 

overallMean <- function(namesReplicates, path, pathReplicates){
  #use the first replicate as the final output
  replicate1 <- get(load(paste0(pathReplicates, namesReplicates[1])))
  meanRep1 <- meanPartition(replicate1)
  #check if empty element in meanRep1 if yes, element removed
  meanRep1 <- deleteEmptylist(meanRep1)
  
  for (i in 2:length(namesReplicates)){
    replicate <- get(load(paste0(pathReplicates, namesReplicates[i])))
    meanRep <- meanPartition(replicate)
    meanRep <- deleteEmptylist(meanRep)
    for (rdn in 1:(length(meanRep)-1)){
      randomType <- meanRep[[rdn]]
      for(d in 1:length(randomType)){
        meanRep1[[rdn]][[d]] <- meanRep1[[rdn]][[d]] + randomType[[d]]
        
      }
    }
  }
  
  #Divide the sums by the number of replicates
  for(rdn in 1:(length(meanRep1)-1)){
    nbrReplicates <- length(namesReplicates)
    namesPartitions <- names(meanRep1[[rdn]])
    meanRep1[[rdn]] <- lapply(names(meanRep1[[rdn]]), function(x) meanRep1[[rdn]][[x]] / nbrReplicates)
    names(meanRep1[[rdn]]) <- namesPartitions
  }
  digitReplicate <- unique(str_extract(namesReplicates, "(?<=\\_)[:digit:]"))
  nameReplicate <- unique(gsub("\\_..*", "", namesReplicates))
  namefile <- file.path(path, sprintf("overallError%s_%s", nameReplicate, digitReplicate))
  save(meanRep1, file = paste0(namefile, ".RData"))
}


