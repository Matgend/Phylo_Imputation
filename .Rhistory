}
start_time <- Sys.time()
imputedTrait <- do.call(MixedImputationApproaches[[method]], MixedImputationApproaches[[method + 1]])
print(paste(MixedImputationApproaches[[method]], v))
end_time <- Sys.time()
imputedData <- c(imputedData, list(imputedTrait))
if(is.null(imputedTrait)){
time <- c(time, NA)
}
if(!is.null(imputedTrait)){
time <- c(time, end_time - start_time)
}
if(rdn == 4){
error <- imputationError(imputedTrait, trueData, partition,
paste(MixedImputationApproaches[[method]], subdatasNames[p, 3], v, sep = "/"))
}
if(rdn != 4){
error <- imputationError(imputedTrait, trueData, partition,
paste(MixedImputationApproaches[[method]], subdatasNames[p, 4], v, sep = "/"))
}
#print("3method")
#print(error)
if(!is.null(errorSubdata)){
errorSubdata <- merge(errorSubdata, error, by = "trait")
}
if(is.null(errorSubdata)){
errorSubdata <- error
}
print(errorSubdata)
method <- method + 2
}
}
}
errorDataframes <- c(errorDataframes, list(errorSubdata))
#OutputErrorsNames <- unique(errorDataframeNames)
#errorSubdataPhylo <- c(errorSubdataPhylo, list(errorSubdata))
# print("--------")
# print(errorDataframeNames)
# print("*******")
# print(imputedDataNames)
# print("------")
# print(rdn)
OutputErrorsDataframes[[rdn]] <- errorDataframes
names(OutputErrorsDataframes[[rdn]]) <- errorDataframeNames
names(OutputErrorsDataframes)[rdn] <- paste("Error", names(replicate)[rdn], sep = "/")
OutputImputedData[[rdn]] <- imputedData
names(OutputImputedData[[rdn]]) <- imputedDataNames
names(OutputImputedData)[rdn] <- paste("Imputed", names(replicate)[rdn], sep = "/")
}
TimeDataframe <- data.frame(random_Type = randomType, partition = partitionName,
missing_Degree = missingDegree, variance_fractions = var_fraction,
impute_Approach = imputeApproachName, time = time)
#remove rows with missingData
TimeDataframe <- TimeDataframe[-which(is.na(TimeDataframe$time)), ]
#OutputReplicate[[r]] <- TimeDataframe
#OutputReplicateNames <- paste0("TimeDataframe", r)
#OutputImputedData[[r]] <- imputedData
#OutputErrorsDataframes[rdn] <- errorDataframes
#OutputImputedDataNames[[r]] <- imputedDataNames
#names(OutputReplicate)[r] <- paste0("TimeDataframe", r)
#names(OutputErrorsDataframes) <- paste0()
#names(OutputErrorsDataframes[[r]]) <- OutputErrorsNames
#names(OutputImputedData[[r]]) <- OutputImputedDataNames
#if(OutputErrorsNames != errorDataframeNames[1]){
# OutputErrorsNames <- paste0("ErrorsReplicate", r)
#}
FinalOutput[[r]] <- list(TimeDataframe = TimeDataframe,
MCAR = list(Error = OutputErrorsDataframes[[1]], Imputed = OutputImputedData[[1]]),
MAR = list(Error = OutputErrorsDataframes[[2]], Imputed = OutputImputedData[[2]]),
MNAR = list(Error = OutputErrorsDataframes[[3]], Imputed = OutputImputedData[[3]]),
PhyloNA = list(Error = OutputErrorsDataframes[[4]], Imputed = OutputImputedData[[4]])))
names(FinalOutput)[r] <- paste0("replicate", r)
print(length(randomType))
print(length(missingDegree))
# # #print(head(missingDegree, 50))
print(length(partitionName))
# # #print(head(partitionName, 50))
print(length(imputeApproachName))
# # #print(head(imputeApproachName, 50))
print(length(var_fraction))
# # #print(head(var_fraction, 50))
# # #print(head(var_fraction))
print(length(time))
}
#save all data generated by replicates
FinalOutput <- list()
#save time
for(r in 1:2){
#save error by replicates (MCAR, MAR, MNAR, PhyloNA)
OutputErrorsDataframes <- list()
#OutputErrorsNames <- c()
#save imputed data
OutputImputedData <- list()
OutputImputedDataNames <- c()
#OutputReplicate <- list()
#OutputReplicateNames <- c()
#for(r in 1:length(NaNImputed$DataNaN)){
replicate <- NaNImputed$DataNaN[[r]]
#variables to define for imputation
nbrMI <- 5
k <- 2
numFun <- weightedMedian
catFun <- maxCat
variance_fractions = c(0.4, 0.6, 0.8)
#Define columns for TimeDataframe
randomType <- c()
missingDegree <- c()
partitionName <- c()
imputeApproachName <- c() #next loop
var_fraction <- c() #next lopp
time <- c() #next loop
#errorSubdataPhylo <- list()
#errorSubdataPhyloNames <- c()
#for(rdn in 1:2){
for(rdn in 1:length(replicate)){
errorDataframes <- list()
errorDataframeNames <- c()
imputedData <- list()
imputedDataNames <- c()
randomApproaches <- replicate[[rdn]]
subdatasNames <- str_split(names(randomApproaches), "/", simplify = TRUE)
#define error dataframe, contain error value for each trait containing missing values
uniqueErrorName <- "error"
errorSubdata <- NULL
#for(p in 12:15){
for (p in (1:length(randomApproaches))){
partition <- randomApproaches[[p]]
#print("__________")
#print(rdn)
#print(p)
#print("__________")
randomType <- c(randomType, rep(subdatasNames[,1][p], each = (length(ImputationApproachesNames) +
length(tail(ImputationApproachesNames,3))*2)))
missingDegree <- c(missingDegree, rep(subdatasNames[, ncol(subdatasNames)][p],
each = (length(ImputationApproachesNames) +
length(tail(ImputationApproachesNames,3))*2)))
#define column partitionName
rows <- paste(sort(unique(as.character(str_extract(colnames(partition), "(?<=\\/)\\d+")))), collapse = "/")
pName <- rep(paste(subdatasNames[,2][p], rows, sep = "/"),
each = (2 +length(tail(ImputationApproachesNames,3))*length(variance_fractions)))
#name of an error dataframe + new dataframe
errorName <- paste(r, unique(randomType)[rdn], unique(pName), sep = "/")
#load true data
trueData <- Data$FinalData[, names(partition), drop = FALSE]
if(rdn == length(replicate)){
pName <- rep(subdatasNames[,2][p], each = (length(ImputationApproachesNames) +
length(tail(ImputationApproachesNames,3))*2))
missD <- rep(unique(missingDegree), (length(randomApproaches) / length(unique(missingDegree))))
errorName <- paste(r, unique(randomType)[rdn], unique(pName), missD[p], sep = "/")
trueData <- Data$FinalData[row.names(partition), names(partition), drop = FALSE]
#print(uniqueErrorName)
#print(errorName)
}
partitionName <- c(partitionName, pName)
print(errorName)
print(uniqueErrorName)
# print(errorDataframes)
if(!is.null(errorSubdata) & errorName != uniqueErrorName){
#print("enter")
errorDataframes <- c(errorDataframes, list(errorSubdata))
}
if(errorName != uniqueErrorName){
if(rdn == length(replicate)){
#errorN <- paste(r, randomType[p], unique(pName), sep = "/")
errorDataframeNames <- c(errorDataframeNames, errorName)
}
uniqueErrorName <- errorName
approachesName <- rep(ImputationApproachesNames[-c(1,2)], length(variance_fractions))
var_frac <- rep(variance_fractions, each = length(ImputationApproachesNames[-c(1,2)]))
if(rdn != length(replicate)){
errorDataframeNames <- c(errorDataframeNames, uniqueErrorName)
}
errorSubdata <- NULL
}
#imputed Data names
approachesName <- rep(ImputationApproachesNames[-c(1,2)], length(variance_fractions))
var_frac <- rep(variance_fractions, each = length(ImputationApproachesNames[-c(1,2)]))
if(rdn != length(replicate)){
missD <- rep(unique(missingDegree), (length(randomApproaches) / length(unique(missingDegree))))
errorName <- paste(r, unique(randomType)[rdn], unique(pName), missD[p], sep = "/")
}
if(length(grep("I.", names(partition))) == ncol(partition)){
impName <- paste(errorName, ImputationApproachesNames[1], "Imputed", sep = "/")
imputedDataNames <- c(imputedDataNames, c(impName, paste(errorName, var_frac,
approachesName, "Imputed", sep = "/")))
}
if(length(grep("F.", names(partition))) == ncol(partition)){
impName <- paste(errorName, ImputationApproachesNames[2], "Imputed", sep = "/")
imputedDataNames <- c(imputedDataNames, c(impName, paste(errorName, var_frac,
approachesName, "Imputed", sep = "/")))
}
if(length(grep("F.", names(partition))) != ncol(partition) &
length(grep("I.", names(partition))) != ncol(partition)){
imputedDataNames <- c(imputedDataNames, paste(errorName, approachesName, "Imputed", sep = "/"))
}
# print("??????????????????????")
#print(imputedDataNames)
#print(errorDataframeNames)
imputeA <- NA
varf <- NA
t <- NA
error <- NULL
#only discrete data
if(length(grep("I.", names(partition))) == ncol(partition)){
start_time <- Sys.time()
imputedTrait <- imputeDiscreteTraits(partition)
end_time <- Sys.time()
imputeA <- ImputationApproachesNames[1]
varf <- 1
if(rdn == 4){
error <- imputationError(imputedTrait, trueData, partition,
paste(imputeA, subdatasNames[p, 3], sep = "/"))
}
else{
error <- imputationError(imputedTrait, trueData, partition, paste(imputeA, subdatasNames[p, 4], sep = "/"))
}
t <- end_time - start_time
#print("discr")
#print(error)
imputedData <- c(imputedData, list(imputedTrait))
#save imputed Data
#ImputedDataNames <- c(ImputedDataNames, paste(names(subdatas)[subdata], "imputeDiscrete", sep = "/"))
}
imputeApproachName <- c(imputeApproachName, imputeA)
var_fraction <- c(var_fraction, varf)
time <- c(time, t)
imputeA <- NA
varf <- NA
t <- NA
#only continuous data
if(length(grep("F.", names(partition))) == ncol(partition)){
start_time <- Sys.time()
imputedTrait <- imputeContinousTraits(partition)
end_time <- Sys.time()
imputeA <- ImputationApproachesNames[2]
varf <- 1
if(rdn == 4){
error <- imputationError(imputedTrait, trueData, partition, paste(imputeA, subdatasNames[p, 3], sep = "/"))
}
else{
error <- imputationError(imputedTrait, trueData, partition, paste(imputeA, subdatasNames[p, 4], sep = "/"))
}
#print("conti")
#print(error)
t <- end_time - start_time
imputedData <- c(imputedData, list(imputedTrait))
}
imputeApproachName <- c(imputeApproachName, imputeA)
var_fraction <- c(var_fraction, varf)
time <- c(time, t)
if(!is.null(errorSubdata) & !is.null(error)){
errorSubdata <- merge(errorSubdata, error, by = "trait")
}
if(is.null(errorSubdata) & !is.null(error)){
errorSubdata <- error
}
#print(errorSubdata)
#mixed and/or only continuous and/or only discrete data
for(v in variance_fractions){
method <- 1
while(method < ((length(ImputationApproachesNames) - 2) * 2)){
MixedImputationApproaches <- list("imputeMICE", list(partition, nbrMI, method = "pmm",
v),
"imputeMissForest", list(partition, v,
maxiter = 10, ntree = 100,
mtry = sqrt(ncol(partition))),
"imputeKNN", list(partition, k, numFun, catFun,
v))
imputeApproachName <- c(imputeApproachName, MixedImputationApproaches[[method]])
var_fraction <- c(var_fraction, v)
#univariate, missrandomForest and imputeKNN don't work.
if((MixedImputationApproaches[[method]] == "imputeMICE" |
MixedImputationApproaches[[method]] == "imputeMissForest" |
MixedImputationApproaches[[method]] == "imputeKNN") & ncol(partition) == 1){
method <- method + 2
time <- c(time, NA)
next
}
start_time <- Sys.time()
imputedTrait <- do.call(MixedImputationApproaches[[method]], MixedImputationApproaches[[method + 1]])
print(paste(MixedImputationApproaches[[method]], v))
end_time <- Sys.time()
imputedData <- c(imputedData, list(imputedTrait))
if(is.null(imputedTrait)){
time <- c(time, NA)
}
if(!is.null(imputedTrait)){
time <- c(time, end_time - start_time)
}
if(rdn == 4){
error <- imputationError(imputedTrait, trueData, partition,
paste(MixedImputationApproaches[[method]], subdatasNames[p, 3], v, sep = "/"))
}
if(rdn != 4){
error <- imputationError(imputedTrait, trueData, partition,
paste(MixedImputationApproaches[[method]], subdatasNames[p, 4], v, sep = "/"))
}
#print("3method")
#print(error)
if(!is.null(errorSubdata)){
errorSubdata <- merge(errorSubdata, error, by = "trait")
}
if(is.null(errorSubdata)){
errorSubdata <- error
}
print(errorSubdata)
method <- method + 2
}
}
}
errorDataframes <- c(errorDataframes, list(errorSubdata))
#OutputErrorsNames <- unique(errorDataframeNames)
#errorSubdataPhylo <- c(errorSubdataPhylo, list(errorSubdata))
# print("--------")
# print(errorDataframeNames)
# print("*******")
# print(imputedDataNames)
# print("------")
# print(rdn)
OutputErrorsDataframes[[rdn]] <- errorDataframes
names(OutputErrorsDataframes[[rdn]]) <- errorDataframeNames
names(OutputErrorsDataframes)[rdn] <- paste("Error", names(replicate)[rdn], sep = "/")
OutputImputedData[[rdn]] <- imputedData
names(OutputImputedData[[rdn]]) <- imputedDataNames
names(OutputImputedData)[rdn] <- paste("Imputed", names(replicate)[rdn], sep = "/")
}
TimeDataframe <- data.frame(random_Type = randomType, partition = partitionName,
missing_Degree = missingDegree, variance_fractions = var_fraction,
impute_Approach = imputeApproachName, time = time)
#remove rows with missingData
TimeDataframe <- TimeDataframe[-which(is.na(TimeDataframe$time)), ]
#OutputReplicate[[r]] <- TimeDataframe
#OutputReplicateNames <- paste0("TimeDataframe", r)
#OutputImputedData[[r]] <- imputedData
#OutputErrorsDataframes[rdn] <- errorDataframes
#OutputImputedDataNames[[r]] <- imputedDataNames
#names(OutputReplicate)[r] <- paste0("TimeDataframe", r)
#names(OutputErrorsDataframes) <- paste0()
#names(OutputErrorsDataframes[[r]]) <- OutputErrorsNames
#names(OutputImputedData[[r]]) <- OutputImputedDataNames
#if(OutputErrorsNames != errorDataframeNames[1]){
# OutputErrorsNames <- paste0("ErrorsReplicate", r)
#}
FinalOutput[[r]] <- list(TimeDataframe = TimeDataframe,
MCAR = list(Error = OutputErrorsDataframes[[1]], Imputed = OutputImputedData[[1]]),
MAR = list(Error = OutputErrorsDataframes[[2]], Imputed = OutputImputedData[[2]]),
MNAR = list(Error = OutputErrorsDataframes[[3]], Imputed = OutputImputedData[[3]]),
PhyloNA = list(Error = OutputErrorsDataframes[[4]], Imputed = OutputImputedData[[4]]))
names(FinalOutput)[r] <- paste0("replicate", r)
print(length(randomType))
print(length(missingDegree))
# # #print(head(missingDegree, 50))
print(length(partitionName))
# # #print(head(partitionName, 50))
print(length(imputeApproachName))
# # #print(head(imputeApproachName, 50))
print(length(var_fraction))
# # #print(head(var_fraction, 50))
# # #print(head(var_fraction))
print(length(time))
}
FinalOutput$replicate2$PhyloNA$Error$`2/PhyloNaN/2/0.35`
getwd()
save(FinalOutput, file="ErrorsImputation.RData")
NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.2`
NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
#' @return a data.frame of 1 factor column with the NAs replaced by values.
missing <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
missingData <- missingData[ ,2, drop = F]
#missingData <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.05`[,2, drop = F]
#missingData
#onetestCat <- missingData
#onetestCat
imputeOneDisceteTrait(missingData)
#missingData <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
#missingData <- partition[,2, drop = F]
imputeOneDisceteTrait <- function(missingData){
#check if tips in matrix traits are ordered as in the tree
if(!setequal(Data$TreeList$`0`$tip.label, row.names(missingData))){
#change order of the rows, match the order of the phylogeny
missingData <- missingData[match(Data$TreeList$`0`$tip.label, row.names(missingData)), drop = FALSE]
}
colName <- names(missingData)
#print(missingData)
#get the right tree
correlationGroup <- as.numeric(str_extract(colnames(missingData), "(?<=\\.)\\d+"))[1]
tree <- Data$TreeList[[correlationGroup + 1]]
AICndMap <- calculateAIC(tree, missingData, "ER")
#Calculate AIC
AIC <- AICndMap$AIC
models <- c("SYM", "ARD")
model <- "ER"
for (i in 1:length(models)){
AICndMaPDiffModel <- calculateAIC(tree, missingData, model = models[i])
#FitCorHMMDiffModel <- corHMM::corHMM(phy = tree, data = missingData, model = models[i],
#rate.cat = 1, get.tip.states = TRUE)
AICndMaPDiffModel
#Calculate AIC
AICDiffModel <- AICndMaPDiffModel$AIC
if(AIC > AICDiffModel){
AIC <- AICDiffModel
AICndMap <- AICndMaPDiffModel
model <- models[i]
}
}
# Imputation
if(AICndMap$index == 0){
MostLikelyState <- apply(AICndMap$map, 1, which.max)
MostLikelyState <- MostLikelyState - 1
}
#MostLikelyState <- apply(FitCorHMM$tip.states, 1, which.max)
else{
MostLikelyState <- apply(AICndMap$map$tips, 1, function(x) which.max(x))
MostLikelyState <- as.data.frame(as.factor(MostLikelyState - 1))
}
MostLikelyState <- as.data.frame(MostLikelyState)
colnames(MostLikelyState) <- colName
return(MostLikelyState)
}
missing <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
missingData <- missingData[ ,2, drop = F]
if(!setequal(Data$TreeList$`0`$tip.label, row.names(missingData))){
#change order of the rows, match the order of the phylogeny
missingData <- missingData[match(Data$TreeList$`0`$tip.label, row.names(missingData)), drop = FALSE]
}
missingData <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
missingData <- missingData[ ,2 , drop = F]
if(!setequal(Data$TreeList$`0`$tip.label, row.names(missingData))){
#change order of the rows, match the order of the phylogeny
missingData <- missingData[match(Data$TreeList$`0`$tip.label, row.names(missingData)), drop = FALSE]
}
colName <- names(missingData)
#get the right tree
correlationGroup <- as.numeric(str_extract(colnames(missingData), "(?<=\\.)\\d+"))[1]
tree <- Data$TreeList[[correlationGroup + 1]]
#add the tip names in the dataframe
missingData <- cbind(species = row.names(missingData), missingData)
#convert missingData as character
missingData[,2] <- as.character(missingData[,2])
missingData[,2][which(is.na(missingData[,2]))] <- "?" #replace NA by "?"because corHMM don't like it
#Define the rate model
model <- "ER"
FitCorHMM <- corHMM::corHMM(phy = tree, data = missingData, model = model,
rate.cat = 1, get.tip.states = TRUE)
FinalOutput$replicate1$TimeDataframe
missingData <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
missingData
if(!setequal(Data$TreeList$`0`$tip.label, row.names(missingData))){
#change order of the rows, match the order of the phylogeny
missingData <- missingData[match(Data$TreeList$`0`$tip.label, row.names(missingData)), drop = FALSE]
}
colName <- names(missingData)
#get the right tree
correlationGroup <- as.numeric(str_extract(colnames(missingData), "(?<=\\.)\\d+"))[1]
tree <- Data$TreeList[[correlationGroup + 1]]
#add the tip names in the dataframe
missingData <- cbind(species = row.names(missingData), missingData)
#convert missingData as character
missingData[,2] <- as.character(missingData[,2])
missingData[,2][which(is.na(missingData[,2]))] <- "?" #replace NA by "?"because corHMM don't like it
#Define the rate model
model <- "ER"
FitCorHMM <- corHMM::corHMM(phy = tree, data = missingData, model = model,
rate.cat = 1, get.tip.states = TRUE)
missingData <- missingData[ ,2 , drop = F]
if(!setequal(Data$TreeList$`0`$tip.label, row.names(missingData))){
#change order of the rows, match the order of the phylogeny
missingData <- missingData[match(Data$TreeList$`0`$tip.label, row.names(missingData)), drop = FALSE]
}
colName <- names(missingData)
#get the right tree
correlationGroup <- as.numeric(str_extract(colnames(missingData), "(?<=\\.)\\d+"))[1]
tree <- Data$TreeList[[correlationGroup + 1]]
#add the tip names in the dataframe
missingData <- cbind(species = row.names(missingData), missingData)
#convert missingData as character
missingData[,2] <- as.character(missingData[,2])
missingData[,2][which(is.na(missingData[,2]))] <- "?" #replace NA by "?"because corHMM don't like it
#Define the rate model
model <- "ER"
FitCorHMM <- corHMM::corHMM(phy = tree, data = missingData, model = model,
rate.cat = 1, get.tip.states = TRUE)
missingData <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
missingData <- missingData[ ,2 , drop = F]
missingData
if(!setequal(Data$TreeList$`0`$tip.label, row.names(missingData))){
#change order of the rows, match the order of the phylogeny
missingData <- missingData[match(Data$TreeList$`0`$tip.label, row.names(missingData)), drop = FALSE]
}
colName <- names(missingData)
#get the right tree
correlationGroup <- as.numeric(str_extract(colnames(missingData), "(?<=\\.)\\d+"))[1]
tree <- Data$TreeList[[correlationGroup + 1]]
#add the tip names in the dataframe
missingData <- cbind(species = row.names(missingData), missingData)
#convert missingData as character
missingData[,2] <- as.character(missingData[,2])
missingData[,2][which(is.na(missingData[,2]))] <- "?" #replace NA by "?"because corHMM don't like it
#Define the rate model
model <- "ER"
FitCorHMM <- corHMM::corHMM(phy = tree, data = missingData, model = model,
rate.cat = 1, get.tip.states = TRUE)
imputeOneDisceteTrait(missingData)
missingData <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
imputeOneDisceteTrait(missingData)
missingData <- NaNImputed$DataNaN$`1`$MCAR$`MCAR/IndDiscreteTraits/3/0.35`
missingData <- missingData[ ,2 , drop = F]
imputeOneDisceteTrait(missingData)
missingData
NaNImputed$DataNaN$`1`$MNAR$`MNAR/IndDiscreteTraits/3/0.05`
NaNImputed$DataNaN$`1`$MNAR$`MNAR/IndDiscreteTraits/3/0.35`
NaNImputed$DataNaN$`1`$PhyloNaN$`PhyloNaN/2/0.05`
